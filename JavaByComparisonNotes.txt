Java by Comparison - BECOME A JAVA CRAFTSMAN IN 70 EXAMPLES

Foreword
    “Programming is a passion for many, but it also deeply involves empathy and humanity.”

!!! “Writing code is easy. Writing good-quality code takes effort, discipline, and a lot of practice. There are many
    different definitions for code quality. Here’s mine:
        Code Quality
        The quality of code is inversely proportional to the amount of effort to understand it.”

    “Creating code is but only the first step. Code is written once, but it is read and evolved many times. If the
    code we create is of poor quality, even if it appears to function flawlessly, we have increased the cost of
    ownership of that code over time.”

!!  “The difference between average programmers and amazing ones is how easy it is for others to follow their work.”

    “As you read this book, you will quickly relate to mistakes that you may have already made. The first step in
    solving a problem is realizing it.”

!   “I urge you not to rush through this book. Sometimes we have to slow down to gain speed. As you move through
    the book, take time to read each piece of bad code and spend some time identifying things that are wrong. Jot
    them down. Then read through the authors’ explanations”
    “Then, think through possible solutions, again, before jumping in to read the presented solution and the reasoning.”


Welcome
    “Comparing good code to bad code is really helpful when you’re trying to figure out how to code in Java.”

    “In this book, we’ll provide you with 70 before/after code snippets. These snippets will help any beginner in
    Java programming to improve. We identified these snippets during our time of teaching Java to undergraduates at
    the university. They’re all based on code we faced when correcting our students’ programming assignments.”

    “Keep in mind: A fool with a tool is still a fool!”


-------------------------------------------------------------------------------------------------------------------
“Chapter 1 - Start Cleaning Up”

    “Any fool can write code that a computer can understand. Good programmers write code that humans can understand.
    Martin Fowler”

    1. Avoid Unnecessary Comparisons
        “The first logical conditions you learned to write probably consisted of integers and comparison operators,
        and a beginner might use that same way of implementing conditions with boolean values. But those comparisons
        are completely unnecessary—they’re like noise in your code”

        “ if (microscope.isInorganic(sample) == true)”          BAD

         "if (microscope.isInorganic(sample))"                  GOOD

    2. Avoid Negations
        “Has anyone ever told you to “think positively”? Turns out, positive expressions are better in your code than
        negative ones because they’re often easier to grasp and they take up slightly less space.”

        “if (!microscope.isHumanoid(sample)) {                  BAD
            return Result.ALIEN;
        } else {
            return Result.HUMANOID;
        }”

        “if (microscope.isHumanoid(sample)) {                   GOOD
            return Result.HUMANOID;
        } else {
            return Result.ALIEN;
        }”

        “If the code you’re calling comes from a third-party library, you might not have the option to invoke
        different methods. But when you control it, don’t shy away from adding that method to the appropriate
        class—the few lines of code are worth their characters, because they make your code clearer in other places.”

    3. “Return Boolean Expressions Directly”

        if (missions < 0 || name == null || name.trim().isEmpty()) {            BAD
            return false;
        } else {
            return true;
        }

        boolean isValid() {                                                     GOOD
            return missions >= 0 && name != null && !name.trim().isEmpty();
        }

        “There are times when the condition is more complex than this one. If this is the case, you should think
        about breaking it into smaller chunks. Our advice is to capture parts of a condition with variables that have
        meaningful names. ”

    4. Simplify Boolean Expressions
        “When you have to combine several conditions into a single check, it’s better to group them in some way. A
        good grouping depends on the semantics of the condition, and you can try to group by topics or level of
        abstractions. Within a method, you should combine statements that are on a similar level of abstraction. ”

    5. “Avoid NullPointerException in Conditionals”
!!     “When you validate arguments, you have to mind the order: first check for null and only then for domain-specific
       “illegal” values. We recommend that you check for common default values like empty strings or empty lists
       first, and only then conduct more specific checks.”

!       “Also, we’ve changed the order of the checks to reflect the order of the arguments in the method signature.
        This is a good practice, since a proper ordering of parameter validations improves the flow of reading.
        You’re also less likely to forget to validate one of the parameters.”

        “As a rule of thumb, you need parameter validation for public, protected, and default methods. That’s because
        any part of the code can access them, and you might not control how this happens.”

    6. Avoid Switch Fallthrough
        “Some programming language constructs are infamous because of all the bugs they’ve caused over the years.
        One of them is the switch, and you should be careful when you use it”

        “The bug is in the first case of the switch statement. There’s no "break" statement at the end of the case.
        This means that the switch just continues to the next case—it falls through ”

        “The switch statement is infamous for this behavior. It always continues execution until it reaches a break
        statement or the end of the block”

!!      “In the rare case where a missing break is intentional, you should leave a comment!”

        “What if one adds another rank? You would have to adapt this conditional, but that’s easy to forget. The code
        would still run through, and you wouldn’t even notice that there’s something missing! That’s why you should
!!!     always have a fallback branch that captures values that were not explicitly coded. switch statements have
        this built in with the "default" case. Alternatively, you can throw an AssertionError to be sure.”

    7. Always Use Braces
        “There are no curly braces after the if, so the condition applies only to the subsequent line. That makes the
        whole method behave maliciously—the line cruiseControl.grantAdminAccess(user); is always executed and grants
        admin access to any user! What a mess.”

        “Less code is not always better—more readable code is!”

        “You might argue that such an error is unrealistic and would hardly ever happen in practice for
        security-critical code. History tells otherwise; in 2014, Apple engineers had a very similar bug in the
        implementation of Apple’s SSL/TLS protocol for iOS. Attackers exploiting that bug could eavesdrop to any
        secure connection of an Apple device. Scary, isn’t it?

        Always using curly braces out of routine is a good defense against fallthrough bugs, as is always the using
        auto-indentation of your IDE.”

    8. Ensure Code Symmetry
        “In essence, the issue is a lack of code symmetry. Check out this definition by Kent Beck[20]: “Things that
        are almost the same can be divided into parts that are identical and parts that are clearly different.”

        Think about it. Do all branches express a similar concern? Do they show a parallel structure? Or in other
        words, are all three branches really symmetrical?

        The answer is: not really. In the first branch, access is denied. In the second and third branches, access is
        granted. This isn’t symmetrical.”

!!!     “The asymmetry in the code came from the fact that we were mixing authorizing code with non-authorizing code.
        We can improve code symmetry if we separate the two into different blocks of code”

        “First, we handle the unauthorized access, log it, and exit the method. Then, we handle the other two cases
        in an if and a connected else if block.”

  “What Have You Learned?”
    “The best thing you can do now is to try out the things you’ve read about. Take a piece of code you wrote a
    while ago and take a look at it. Can you apply some of the recommendations you’ve read about here? How does your
    code look after these refactorings? Be sure to keep a copy of the original version to compare it against the
    improved one. After all, that’s the theme of this book!”


-------------------------------------------------------------------------------------------------------------------
“Chapter 2 - “Level Up Your Code Style”

    “Good code is short, simple, and symmetrical—the challenge is figuring out how to get there.
    Sean Parent”

    “As the game progresses, your character moves through the game world, interacts with its inhabitants, and gathers
    experience through quests. Eventually, your character will gain new skills and “level up” her skills to a new a
    stage of mastery, becoming faster, stronger, smarter, or whatever it was you were practicing.”

    9. “Replace Magic Numbers with Constants”
       “Oftentimes when programmers need to represent a set of options in code, they use a set of numbers. Without
       additional context, we call those numbers “magic numbers”: numbers without an apparent meaning that steer the
       program. They make your code harder to understand and more error-prone.”

       “This time, we got rid of the magic part. We’ve done this by assigning each number a meaningful and
       accessible name.”

        (BASICALLY the solution would be to define constants)

    10. “Favor Enums Over Integer Constants”
        “Constants, as you’ve seen them in the previous comparison, Replace Magic Numbers with Constants, are a big
        improvement over magic numbers. But in case you can enumerate all options, Java’s type system offers an even
        better solution.”

        “In statically typed languages like Java, there are features that you should use to spot such errors as early
        as possible, even before the program is executed the first time. The earlier you spot an error, the cheaper
        it is to fix it!”

        (once you replaced some magic numbers with an Enum, you can use the Enum even in method signatures, so instead
        of getting a int/Integer parameter, your method would have SHUTTLE_SPEED, your ENUM, as parameter, if only those
        values from the ENUM are expected)

        “The key advantage here is that you can no longer put a nonexistent SpeedPreset into the setPreset() method.
        Even if you try, the Java compiler will stop you.”

    11. “Favor For-Each Over For Loops”
        “Most of the time, you don’t really need the level of detail that an index variable gives you. In those cases,
         you should write loops in a different way, such that the low-level details of the iteration aren’t just
         protected but are also hidden from the programmer.”

!!!     “No need to handle an iteration index anymore! And it even works for arrays and unindexed collections like Set.”

        “Another alternative looping mechanism is using an iterator like in Avoid Collection Modification During Iteration.”

        “The rare cases where index-based iteration makes sense is when you only iterate over special parts of collections
        or you explicitly need the index for other purposes.”

    12. “Avoid Collection Modification During Iteration”
        “The problem is that we call supplies.remove(supply) while we’re inside a for loop that iterates over the supplies”
!!!     “In this situation, a standard implementation of the List interface, or indeed of other Collection interfaces such
         as Set or Queue, will throw a ConcurrentModificationException. We can’t simply modify a List while we iterate over it.”

        “The name ConcurrentModificationException makes many people wonder about concurrency in their single-threaded
        application. That’s quite misleading, since no actual concurrency takes place here! Instead, we iterate over the
        Collection, and while we’re doing that, we modify that collection. Unfortunately, no compile-time check in Java
        saves us from this error.”

!!      “The solution we’ve depicted here uses another way of iteration: a while loop that relies on the Iterator of our
        supplies collection. The Iterator is our rescue. It acts like a pointer to an element in the list, starting with
        the first one. We can ask if any elements are left via hasNext(), get the next() element, and safely remove()
        the last element returned.

        Although we can’t modify a List directly, the iterator is perfectly capable of doing this. Its job is to make sure
        that everything works during the iteration.”

        “Since Java 8, you can also use the new Collection.removeIf() method that makes use of lambdas. But be sure to
        read Chapter 8, Let Your Data Flow before you use that method!”

    13. “Avoid Compute-Intense Operations During Iteration”
        “When you iterate over a data structure, you need to be careful with what kind of operations you perform. If you
        do something that is compute-intense, it can easily turn into a performance pitfall. The code above shows a typical
        example for this with the method find() that locates Supply objects with a regular expression.”

        “Compiling a regex automaton consumes time and processing power, just as the compilation of a class takes time.
        Usually, it’s a one-time effort, but here the regex is compiled on every iteration.
        Be aware that some other very popular methods in the Java API, such as String.replaceAll(), behave the same way!”

        “The solution to the potential performance pitfall is very simple: make sure that the computation-intense
        operation takes place as rarely as possible.”

    14. “Group with New Lines”
        “What’s missing is space! In particular, getConversionRate() glues all lines of code together. But is this really
        a single block or does it consist of different parts? We can improve the readability of the code by adding empty
        lines that act as a separator. It’s similar to this book, which captures single thoughts or arguments within
        paragraphs separated by new lines.”

!!      “As a rule of thumb, you should try to group related code and concepts together and separate different groups
        from each other through empty lines”

!!      “The concept of vertical space goes even further. Robert C. Martin uses the metaphor of a newspaper in his book
        Clean Code[Mar08] for describing vertical formatting. A good article starts with the title (class name), goes over
        section headings (public members, constructors, and methods), down to its very details (private methods). If you
        structure your code this way, you’ll find it much easier to make sense of a class already if you only scroll over
        the code. Chances are, it’s easier to locate features in the class as well.”

    15. “Favor Format Over Concatenation”
!       If you have to build large strings, you can use format strings to make them more readable.

        “Format strings help to overcome this issue, and they’re available in practically any contemporary programming
        language—not just in Java. The key lies in separating the layout of a String (how it is printed) from the data
        (what is being printed). Format strings define a coherent String in a single block using special placeholder
        characters, marked by %”

        “Point taken that it’s not so easy to see what "%S: [%tm-%<te-%<tY](Day %d)> %s%n" will print in the end. But
        it’s a well-documented standard[23] and actually a good alternative to the cluttered code from the problem—for
        large strings we recommend StringTemplate,[24] a powerful template engine.”

!!!     “Consider documenting the formatted string with a few examples similar to Document Using Examples so that the
        next developer reading your code doesn’t have to look up how %S or any other special formatting syntax behaves
        to know what the resulting string will be.”

    16. “Favor Java API Over DIY”
        “Times have changed. The Java API is huge, and it comes with many classes that can help you get the job done,
        such as String or List. Instead of reimplementing functionality from the API, you should reuse it whenever possible.
        Experts have written and optimized the Java API over time, resulting in a fast and practically bug-free standard
        library.”

        int getQuantity(Supply supply) {                                            BAD
            if (supply == null) {
               throw new NullPointerException("supply must not be null");
            }

            int quantity = 0;
            for (Supply supplyInStock : supplies) {
                if (supply.equals(supplyInStock)) {
                    quantity++;
               }
           }

          return quantity;

        }

        int getQuantity(Supply supply) {                                          GOOD
            Objects.requireNonNull(supply, "supply must not be null");

            return Collections.frequency(supplies, supply);
        }

        “The utility class Collections provides a frequency() method that counts the number of occurrences of objects in
        a Collection. Plus, we have used the method requireNonNull() from the utility class Objects”

        “And just as important, the API received and receives extensive testing worldwide, which is probably more than
        you can do. Chances are that your code is more prone to bugs than the API.”

!!!!!   “Knowing the API well is what makes a true Java professional. You save time if you don’t reimplement (and test)
        functionality that’s already there.”

!!!!    “That last part’s important, and the learning doesn’t stop here. The Java API is huge—really huge. In Java 9,
        there are more than 4,000 public API classes alone. Each one of these has a purpose that can help you. We don’t
        recommend that you go through all of them right now. But when you’re programming, ask yourself now and then,
        “Could this piece of code be useful in a different context as well?” If the answer is yes, then there’s a chance
        that you can find a helpful class in the Java API. So you should try searching the API at least briefly.”
            (OR YOU can search google/StackOverflow and ChatGPT to quickly find if your code can be replaced with existing
            API)

        “Eventually, you’ll learn about other helpful classes, similar to Collections or Objects. And you’ll get more
        and more proficient in using them over time. In the end, knowing your API is what makes a true professional.”


-------------------------------------------------------------------------------------------------------------------
“Chapter 3 - Use Comments Wisely”

    “Good code is its own best documentation. As you’re about to add a comment, ask yourself, “How can I improve the code
    so that this comment isn’t needed?”
        Steve McConnel”

    “Unfortunately, code comments are often like our smart TV’s manual—not helpful.”

    17. Remove Superfluous Comments
        comments that are superfluous are the ones that repeat what the code says

!!!!    “If you can’t fix a TODO, create an issue in your issue tracker instead where you can discuss and track that
        problem until it’s fixed.”

    18. “Remove Commented-Out Code”
        “In any bigger code base, you’re guaranteed to find sections of commented-out code. These types of comments are
        just clutter.”

        “Programmers usually comment out code because it prevents them from getting a feature to work. They’re focused
        on other aspects, and commenting gives them an easy way out. Some are also afraid of losing code they might need
        again in the future and prefer to comment it instead.”

        “Fortunately, commented-out code is very easy to deal with: just remove it.”

    19. “Replace Comments with Constants”
        “The benefit of these constants is that they explain their meaning in their names. That’s why there’s no longer
        any need for additional explanation with comments: the comments have turned into actual code.”

        “Comments always have a risk of becoming stale. Programmers rarely apply the same rigor to comments as they do
        to code. Someone might change the code but ignore the comment, or they might add a new conversion rate without
        documenting it.”

    20. “Replace Comments with Utility Methods”
        (one would think that you can just create a local variable..)
        “This clarifies the code and gets rid of the comment. But it adds another variable to the method, and that one is
        pretty redundant. After all, it’s returned right away.”

        “To sum up, when you replace comments with utility methods, you don’t just get rid of a line of text—you can
        make your code more modular and balance abstraction levels.”

    21. Document Implementation Decisions
        “Consider the code above. Are you wondering why the programmer decided to use a binarySearch? Well, at least he
        left us a (helpful) comment: it has to be fast.”

        // fast implementation                                                  BAD

        /*                                                                       GOOD
         * In the context of checking availability of supplies by name,
         * facing severe performance issues with >1000 supplies
         * we decided to use the binary search algorithm
         * to achieve item retrieval within 1 second,
         * accepting that we must keep the supplies sorted.
         */

        Excerpt From: Jörg Lenhard. “Java By Comparison”. Apple Books.

        “Now that comment is a lot more informative. It states the use case, concerns, the solution, and also any
        trade-offs or costs we have to pay.”

!!!!!!  “The comment isn’t just more helpful now. It’s also easy to write. We simply used a template[25] and filled in
        the necessary bits. Take a look at it:

            In the context of [USE CASE],
            facing [CONCERN]
            we decided for [OPTION]
            to achieve [QUALITY],
            accepting [DOWNSIDE]”

        “Use this template for documenting important decisions or tricky parts of your code. It needn’t be exactly the
        one you see here, but convention helps.”

    22. Document Using Examples
        “Some programming constructs are very powerful, but also very complex. Regular expressions fall into this
        category. You should document complex constructs in a way that makes them easier to understand.”

          /**                                                                   GOOD comment with examples
            * The expression universally identifies a supply code.
            *
            * Format: "S<inventory-number>\<COUNTRY-CODE>.<name>"
            *
            * Valid examples: "S12345\US.pasta", "S08342\CN.wrench",
            * "S88888\EU.laptop", "S12233\RU.brush"
            *
            * Invalid examples:
            * "R12345\RU.fuel"      (Resource, not supply)
            * "S1234\US.light"      (Need five digits)
            * "S01234\AI.coconut"   (Wrong country code. Use US, EU, RU, or CN)
            * " S88888\EU.laptop "  (Trailing whitespaces)
            */

        Excerpt From: Jörg Lenhard. “Java By Comparison”. Apple Books.

    23. “Structure JavaDoc of Packages”
!!      “JavaDoc is the documentation facility for APIs in Java. You use it to document anything that’s public in
        your code, including packages. If you’re writing an API and you want others to use it, that’s a must.”

        “There are three parts here, separated by vertical space, and no more superfluous information.
        The introductory sentence provides a (very) short summary of what you can achieve with the classes in this package.
        The second part describes what you can get done with the most important classes in this package. This gives you
        the starting point for looking deeper into the package and also a pretty good idea whether you need it. And by
        using the @link annotation, you can simply click on the class and jump directly to it—the JavaDoc tool even checks
        that linked classes exist when it generates the documentation.
        Instead of annotations like @author, which capture information that is in the version control system anyway, we
        provide a concrete example of how to implement the most important use case in the third part. That’s something a
        developer can use instantaneously.”

    24. “Structure JavaDoc of Classes and Interfaces”
!!!     “Chances are you already know this, but you should document every public class or interface with JavaDoc. This
        is a rule in practically all Java projects.”

        “So here’s our recommendation for good JavaDoc comments for interfaces and public classes: First, start with a
        short and concise summary. Separate this vertically from invariants the class or interface guarantees. Don’t
        just duplicate method signatures.
        And examples always help! So sit down and have a go at an example for how to use the interface above.”

    25. “Structure JavaDoc of Methods”
        “No. No. And no idea. We have no clue how the method will behave, even though there’s a JavaDoc comment. So if we
        use this method, we’re no longer certain how our code will behave. That would be especially problematic if you’re
        building an API.”

            /**                                                                 GOOD
              * Loads supplies onto the cargo ship.
              *
              * <p>
              * Only lets you load as many supplies as there is remaining capacity.
              *
              * Example:
              * <pre>
              * int capacity = cargoShip.getRemainingCapacity(); // 1
              * Queue&lt;Supply> supplies = Arrays.asList(new Supply("Apple"));
              * Queue&lt;Supply> spareSupplies = cargoShip.load(supplies);
              * spareSupplies.isEmpty(); // true;
              * cargoShip.getRemainingCapacity() == 0; // true
              * </pre>
              *
              * @param supplies to be loaded; must not be null
              * @return supplies that could not be loaded because of too little
              *          capacity; is empty if everything has been loaded
              * @throws NullPointerException if supplies is null
              * @see CargoShip#getRemainingCapacity() check capacity
              * @see CargoShip#unload() unload the supplies
              */

        “The JavaDoc comment reads like a contract. It states how the input and its internal state must be to guarantee
        a certain output and state change.”

        “Even invalid input, such as null, is specified in the @param description, along with the consequences of a
        violation: @throws a NullPointerException.”

    26. “Structure JavaDoc of Constructors”
        “Because constructors lack a name, their JavaDoc is just so important!”

            /**
              * Creates an empty inventory.
              *
              * @see Inventory#Inventory(Collection) instantiate with initial supplies
              */
              Inventory() {
                  this(new ArrayList<>());
              }

            /**
              * Creates an inventory with an initial shipment of supplies.
              *
              * @param initialSupplies Initial supplies.
              *                        Must not be null, can be empty.
              * @throws NullPointerException if initialSupplies is null
              * @see Inventory#Inventory() instantiate with no supplies
              */
              Inventory(Collection<Supply> initialSupplies) {
                  this.supplies = new ArrayList<>(initialSupplies);
              }

        “The first and most important thing you need to know is how to call a constructor correctly. You especially need
        to know what preconditions you have to fulfill so that everything works out as desired. The default constructor
        doesn’t really have preconditions and no input parameter, but the second one does: a Collection of Supply objects
        called initialSupplies. We have to document this one like we do with other method parameters. Here, you’re not
        allowed to enter null, and if you do, then you get a NullPointerException back. The comment states this in
        the @throws part.”

       “Second, you need information about the state of the object when the constructor finishes, because its state
       determines which other methods you can call at this point. That’s called a postcondition. In the code above, the
       inventory’s either going to be in an “empty” state or filled with “initial supplies.” The summary sentences of
       both constructors describe that.”

       “two @see annotations. These annotations provide hints to the developer. They outline alternatives that she may not
        have seen otherwise. Here, we use these annotations to explain the relationship between the two constructors.”


-------------------------------------------------------------------------------------------------------------------
“Chapter 4 - Name Things Right”

    “There are only two hard problems in Computer Science: cache invalidation and naming things.
        Phil Karlton”

    27. “Use Java Naming Conventions”
        “We kept the name of the class because it already follows the conventions: it’s written in CamelCase, beginning
         with a capital letter and starting every term in the name with a capital letter. Interfaces and enums work likewise.”

        “To let the constants (variables that are final and static) stand out, you should write their names in
        CAPITAL_SNAKE_CASE. This means that all letters in the name are uppercase, and you separate terms with an underscore”

        “Methods, fields, parameters, and variables use a variant of camelCase where the first letter starts in lowercase.
        This has the downside of a possible confusion of method (behavior) and variable (state) names since they’re named
        in the same scheme. That’s why their name itself should tell the reader if it’s a method or a variable.
        You should name your methods as verbs, as you see in drive() in the code above, or let them start with verbs
        like is, has, save, get, or set, etc. For variables, use nouns, such as serialNumber or milesPerHour.”

    28. “Follow Getter/Setter Conventions for Frameworks”
        “And last, we renamed the setters and getters to reflect the name of the field. If the field has the name foo
        then the getter and setter should be named getFoo() and setFoo(). Be aware that this changes slightly for a
        boolean field. The name of the setter stays the same, but the getter turns to isFoo() instead—it reads like a question.”

    29. “Avoid Single-Letter Names”

    30. Avoid Abbreviations
        “To sum up, you should try to avoid abbreviations and use them only if they’re very common. If in doubt, spell it out!”

    31. Avoid Meaningless Terms
        “To start with, we simply removed typical meaningless terms like “data,” “info,” or “flag.” It’s rare that such
        terms add any meaning to the code.”

    32. Use Domain Terminology
        “In this book, we put the code examples in a domain inspired by a Mars mission, and we fit all the names into
        this particular domain. This automatically makes the code much clearer.”

        “To sum up: You should align names in your code to the domain it belongs to as far as possible and avoid generic names.”


-------------------------------------------------------------------------------------------------------------------
“Chapter 5 - “Prepare for Things Going Wrong”

    “There are two ways to write error-free programs; only the third works."
        Alan J. Perlis

    “You have to ensure your program against errors even if it’s completely bug-free (and it never is). That’s because
     there are things that you just can’t control”

    “In Java, we ensure our program handle errors by catching and throwing exceptions.”

    33. Fail Fast
        “We separated the normal path from parameter validations and placed the two combined conditions at the top of
        the method. If one of them holds, the method returns immediately and throws an IllegalArgumentException. In
        other words, the method fails fast.”

        “Failing fast makes the whole method more readable and understandable! But not only that, we even got rid of one
        level of indentation for the normal path.”

    34. “Always Catch Most Specific Exception”
        “Exceptions in Java are part of a relatively complex type hierarchy. When you catch an exception, you should always
        catch the most specific exception type. If you catch a more general type, you risk swallowing errors that you shouldn’t.”

        “Exception is the most general exception type in Java. The only thing that’s even more general is the super
        type of Exception: Throwable (this comes from the catch and throw metaphor). If you catch a Throwable, you’ll
        even catch errors in the virtual machine, such as OutOfMemoryError. Don’t do this!”

        “Many beginners find it tempting to catch a very general type. After all, you consume practically any type of error
        with a single statement. But this is only good on the surface. It means that you catch exception types that you
        don’t want to handle here, such as a NullPointerException. In most cases, this exception indicates a bug in your
        code that you need to fix. When it occurs, you want the program to crash so that you become aware of the problem.”

!!!     “Sometimes, catching the most specific exception means that you need to catch many exceptions. This might mean
        that you have to write many catch blocks instead of just a single one. Don’t let the fact that more code is
        needed fool you into believing that catching a general exception type is better! After all, more code with less
        bugs is better than less code with more bugs.”

        “Since Java 7, there’s the multi-catch block. Say you want to handle a NumberFormatException and an IOException
        in the same way. Just write catch(NumberFormatException | IOException e) and combine two catch blocks into one.
        Whichever method you use to structure your catch blocks, be sure to catch the most specific exceptions only.”

    35. “Explain Cause in Message”
        “Exception handling is not only about catching exceptions, but also about throwing them. When throwing an
        exception, you should follow type conventions to make handling of the exception easier.”

        “We can only fix bugs that we can reproduce. Otherwise, we don’t know whether we really fixed them. Typically,
         we start with the stack trace of an exception and trace our way back in
         “the code until we find the root cause. If the exception itself provides a detailed context, this is much easier.”

         throw new IllegalArgumentException();                                                            BAD

         “throw new IllegalArgumentException(                                                           GOOD
         	                String.format("Expected %d, but got %d characters in '%s'",
         	                    Transmission.MESSAGE_LENGTH, rawMessage.length(),
         	                    rawMessage));”

        “throw new IllegalArgumentException(                                                            GOOD
        	                String.format("Expected number, but got '%s' in '%s'",
        	                        rawId, rawMessage));”

 !!!!!  “Instead of missing or useless information, we provide a triplet: what we expect, what we got, and the overall
        context. A developer who traces an exception to its origin will find the source much faster with such detailed information.”

        “What’s more, we can reproduce the situation that causes the exception more easily. Even better, we can reuse such
        triples as test cases—we just need to convert them into JUnit tests to drive a bug fix and act as regression tests
        later on. We’ll get to testing in the next chapter.”

        “You probably already noticed: we use a template for the message of an exception with Favor Format Over Concatenation
        in the form of Expected [EXPECTED], but got [ACTUAL] in [CONTEXT]”
        “You can use any format you like, of course. For us, this one really pays off—when (not if) exceptions occur in production."

    36. “Avoid Breaking the Cause Chain”
        “When tracking down a bug, a detailed cause chain is worth a pile of gold.”

        “For instance, look at the code above. It catches the NumberFormatException and throws a new IllegalArgumentException
        with an informative message instead. No bad exception handling as such—but it breaks the cause chain!”

        “Can you spot the problem? It’s the IllegalArgumentException not getting the reference to its cause, the
        NumberFormatException. Without this link there’s no cause chain. When you look at the stack trace of this
        IllegalArgumentException, you won’t find a hint that it stems from a NumberFormatException or from what line in the
        code. We lost a lot of useful information—the NumberFormatException has its own message that provides more
        information and context on another level of abstraction and its own stack trace with line numbers.”

!!!     “So how can we keep the cause chain instead of breaking it?”

!!!!!   “Exceptions have various constructors and some of them allow us to pass in a Throwable as a cause. By passing in a
        Throwable, we link an exception to its cause, thereby building the cause chain. We recommend that you use the
        constructor Exception(String message, Throwable cause) and provide a message as well.”

!!!     “We’ve seen many kinds of broken cause chains in actual code. Take a look at the worst of all:

            catch (NumberFormatException e) {
                // BAD! Cause chain interrupted!
        	    throw new IllegalArgumentException(e.getCause());                           VERY BAD
        	}
        It seems okay. The throw provides e.getCause() as an input parameter and creates a cause chain, but it removes one
        exception from it, namely the NumberFormatException because it only links its cause, but not the exception itself.”

!!      “So if you need to throw an exception within a catch block, just pass in a message and the caught exception as a cause directly:

            throw new IllegalArgumentException("Message", e);”

    37. “Expose Cause in Variable”
        “We suggest that you define and use a custom exception: the MalformedMessageException (SEE BELOW) with its own raw message field.
        We can obtain that field later on for more detailed end-user information or for a more thorough handling of that exception.”

        final class MalformedMessageException extends IllegalArgumentException {
            final String raw;

            MalformedMessageException(String message, String raw) {
               super(String.format("%s in '%s'", message, raw));
               this.raw = raw;
            }
            MalformedMessageException(String message, String raw, Throwable cause) {
               super(String.format("%s in '%s'", message, raw), cause);
               this.raw = raw;
            }
        }

        “You just need to make sure that your custom exceptions stay immutable, which we do by declaring the class and its fields final.”

    38. “Always Check Type Before Cast”
        “we make sure that we can read the signal by performing a type check using the instanceof operator. This operator
        returns true if signal can be cast to the type CrewMessage and false otherwise. We’re allowed to do the explicit
        cast only if the check was positive. It gives us certainty that a ClassCastException won’t happen here. We’re safe!”

        “So keep in mind that whenever your program interacts with the outside (for example, using a stream), you need to
        make sure that it can handle unexpected input.”

    39. Always Close Resources
        “Programs need system resources, such as disk space, database or network connections, CPU threads, and RAM.
        These resources are limited, and programs have to share them among each other. If a single program acquires resources
        without releasing them, it can bring down the whole environment.”

        “Since Java 7, we can safely and elegantly close resources with the try-with-resources construct. This works for
        any class that implements the AutoCloseable interface, which practically all resource classes of the Java API do.”

    40. “Always Close Multiple Resources”
        “A try-with-resources block isn’t limited to one resource—it can handle multiple resources at the same time. Even when
        something goes wrong, it ensures that all of the resources are always closed. To use multiple resources in a
        try-with-resources, you just need to separate them by a semicolon:

        try (open resource1; open resource2) {
            // use  resources
        }”

!!!!    “Internally, the compiler expands each resource in the try-with-resources block and creates a nesting of multiple
        blocks. The innermost try-finally block uses the opened resources.

        // open resource1
        try {
            // open resource2
            try {
                // use resource1 and resource2
            } finally { resource2.close(); }
        } finally { resource1.close(); }”

!!!    “Hear our advice: don’t manage resources manually—you’ll only shoot yourself in the foot. Open resources in a
        try-with-resources block—and your feet stay unharmed.”

    41. Explain Empty Catch
        “Sometimes, swallowing an exception and doing nothing is actually the right thing to do. Nevertheless, when we
        stumble upon an empty catch block, we always get a weird feeling: Is this a ”
        bug? Was the catch added unintentionally, for example by the IDE, and does it hide the exception? Or is it a
        feature? Did the programmer leave the catch block empty on intention?”

        catch (NotDirectoryException e) {               BAD

        }

        catch (NotDirectoryException ignored) {         GOOD
            // No directory -> no logs!
        }”

!!!!    “First, we renamed the exception variable e to ignored. It’s more self-explanatory and states explicitly that we want
        to ignore the exception. This name is almost a convention. Modern IDEs understand it, too, and no longer warn that
        there’s an empty catch block.
        And second, we add a comment why we ignore the exception. This is important, because others programmers will have
        it easier to comprehend this decision. Since it’s a sort of design decision, we suggest that you use a template here,
        similar to Document Implementation Decisions. The template we propose is CONDITION -> EFFECT. The condition captures
        the reason why the exception has been thrown and the effect states why we can swallow and ignore iT”


    “What Have You Learned?”
        “Handling exceptions is inevitable in any program you write. As you’ve seen in this chapter, it’s easy to get a
        subtle detail wrong with exceptions, such as forgetting to link exceptions into a cause chain or failing to close
        resources properly.”

        “When you make such mistakes, your program will still compile. Java doesn’t force you to provide good messages
        for exceptions or to link them with each other. That’s a problem, because you might realize these issues only at
        a late stage, typically when your program has been deployed to production with real-world data.”


-------------------------------------------------------------------------------------------------------------------
“Chapter 6 - “Assert Things Going Right”

    “Test your code, or your users will.
        Dave Thomas and Andrew Hunt”

    “To err is human. Or to put it differently, we all make mistakes. No matter how brilliant, how well educated, or
    how experienced you are, you’re still going to write buggy code now and then. NASA’s own bugs made its Mars robots
    land too hard, and its rockets accelerated too fast during takeoff. Pac-Man ended at a kill screen at level 256. And
    some really terrible software errors have hurt or even killed people—for example, an X-ray machine that emitted too
    much radiation.”

    42. “Structure Tests Into Given-When-Then”
        “Readability is just as important for testing code as it is for source code. After all, test code is code. But the
        test here looks like it was written in a hurry and without due diligence.”

!!!     “Usually, a test consists of three core parts: given, when, and then. ”

        “The given part sets the stage for the actual test and captures all prerequisites for executing the functionality
        we want to test. The when part triggers the operation that we actually want to test. And in the then part, we assert
        that the result that the when trigger produced is actually what we expect.”

        “There’s a lot you can do in terms of readability with only little changes. Formatting with new lines to separate
        the given-when-then parts is already a big improvement. In a sense, we’ve just applied Group with New Lines
        to highlight the specific structure of the test.”

        or you can add comments:
            // given
            CruiseControl cruiseControl = new CruiseControl();

            // when
            cruiseControl.setPreset(SpeedPreset.PLANETARY_SPEED);

            // then
            Assertions.assertTrue(7667 == cruiseControl.getTargetSpeedKmh());”

    43. Use Meaningful Assertions
        “That message (or rather the lack of one) isn’t helpful when you’re trying to make sense of what’s broken”

        “The solution is actually quite simple. We use a different assertion, one that’s made for checking if two values
        are the same: assertEquals(). With this assertion, JUnit can provide a much better error message when the test
        fails. It’ll look like this:

            expected: <7667> but was <1337>”

    44. “Expected Before Actual Value”      (pay attention to the order of values in the assert statements)
        “t gets more obvious when you run the test and the assertion fails. If that happens, you’ll get a message like this one:

            expected: <1337> but was <7667>

        The message tells you that the two values in the assertEquals() method are different. That’s why the test fails as
        it should. So far so good, but the semantics of the message are wrong. In the test, we expect the number 7667 as the
        correct result and 1337 is the incorrect result that the cruiseControl returns. But the message tells you that it’s
        the other way around.”

!!!!    “The error comes from a mix-up in the arguments to assertEquals()—they’re in the wrong order”
        “Our rule of thumb is: think first about what you expect.”

    45. “Use Reasonable Tolerance Values”
        “When you test floating-point computations, you need to specify a precision”

        “This is easy enough with JUnit. The assertion assertEquals(double expected, double actual, double delta) supports
        a tolerance value called delta. If you need to be exact up to two decimal places, use a tolerance value of
        0.1*10^-2=0.001. Here, we want a precision of four decimal places, resulting in a tolerance value of at least 0.00001.
!!!!    To sum up, you should be aware of precision and specify an acceptable tolerance level whenever you use assertEquals()
        with either float or double.”

    46. “Let JUnit Handle Exceptions”
        “Tests and exceptions often go hand-in-hand. Tests ensure that no exceptions are thrown, or that a particular
         exception must be thrown.”

        “Each JUnit test contains the implicit assertion that no exception occurs. ”

        “In the second test, we use assertThrows(). This assertion explicitly marks that we expect a specific kind of
        exception to be thrown in the test. Looking at the code, you can see that there’s no try–catch block anymore and
        no call to fail(). “Instead, everything’s handled by assertThrows()”

    47. Describe Your Tests
        “When tests fail, the first thing you’ll see is their name. Good names are valuable—they help you find the
        cause for failure faster.”

        “Adding comments might be one option here. But with JUnit5, there are much better solutions.
        So how can we improve the test description here?”

        @Test
        @DisplayName("Expect 44% after filling 22l in an empty 50l tank")
        @Disabled("We don't have small tanks anymore! TODO: Adapt for big tanks")
        void fillTank() {....}

!!!     “The first thing we’ve done is to get rid of superfluous terms in the method names. They no longer start with
        words like test. Instead, they describe the context, the method under test, and the assertion we check”

        “Describing why a test is disabled is important, because it is your motivation for not just deleting the code.
        We suggest that you use the format of @Disabled("[why it’s disabled] TODO: [what’s the plan to enable again]").
        This a) forces you to think about the future of this test when you disable it, and
        b) provides a future developer with the necessary information to enable it again (instead of leaving her high and
        dry without a clue).”

    48. Favor Standalone Tests
        “When we are teaching Java, we often see beginners who love to use the @BeforeEach and @BeforeAll annotations.
        After all, they allow you to extract common setup code that you need in the given part of a test and write it
        only once. That’s a good thing, because it avoids code duplication. But it comes at a price: setup methods make
        tests harder to comprehend.”

        “The key lies in making the connection of the tests to the setup code clearer”

        so instead of for each, they suggest that you extract the common code in another method, and call that method in the test
        “That’s why we extracted the setup part into a static method that we gave a meaningful name: createHalfFilledTank().”

        “Essentially, we’ve made the tests stand alone. A test stands alone when you link the given, when, and then bits
        directly within the test method.”

        “Now you can understand each test independently and you don’t have to look for setup logic that’s implicitly
        linked elsewhere. It’s also easier to move a test from one test class into another, because you no longer have
        implicit dependencies. The compiler will tell you if you forgot something. That’s possible because the test
        stands alone—all dependencies are explicit.”

        “Tests are better if they stand alone and you can understand the complete test just by looking at the test method
        and without having to scroll around in the code.”

    49. Parametrize Your Tests
        “Sometimes, you need to test a method or chain of methods in the same way, but with many different input
        parameters. That’s when you want to make sure that the method works for a large range of values. It’s easy to
        enumerate the parameters in a test method, like in the code above, but this can complicate testing.”

        “The solution here consists of parameterized tests with the @ParameterizedTest and @ValueSource annotations”

    50. “Cover the Edge Cases”
        “ Instead of testing every possibility, you should cover the normal execution path and the settings that are
        most likely to go wrong. Put differently, you should cover edge cases.”

        “Edge cases are highly specific for a piece of code, but usually you should at least try the boundaries of a
        parameter’s data type. ”

    “What Have You Learned?”
        “You can’t have a sophisticated piece of software without testing code. Sometimes (read: quite often), you’ll
        write as much or even more code for testing than you will for implementing the actual functionality”


-------------------------------------------------------------------------------------------------------------------
“Chapter 7 - “Design Your Objects”

    “Any problem in computer science can be solved with another layer of indirection. But that usually will create another problem.
        David Wheeler”

    “This is where design comes in. Our house shouldn’t just be functional. We want the architect to make it beautiful
    and convenient, too. The same applies to our classes and objects in Java. They shouldn’t just be functionally correct.
    They should be beautiful to look at, and they should be convenient to use.”

    “These tricks (read: best practices) are what this chapter is about. We’ll highlight some of Java’s most common
    design principles that help you to produce code that’s more object-oriented (beautiful) and robust (convenient).”

    51. “Split Method with Boolean Parameters”
        “Using a boolean value as a method parameter helps you loudly to proclaim that the method does more than one thing.
        This is sometimes okay, but it generally makes your code less understandable because it’s hard to see on the calling
        side what the boolean parameter actually achieves”

            “void log(String message, boolean classified) throws IOException {                   BAD
                if (classified) {
                    writeMessage(message, CAPTAIN_LOG);
               } else {
                    writeMessage(message, CREW_LOG);
               }
            }”

            “void writeToCaptainLog(String message) throws IOException {                        GOOD
                writeMessage(message, CAPTAIN_LOG);
            }

            void writeToCrewLog(String message) throws IOException {
                writeMessage(message, CREW_LOG);
            }”

!!!!    “To do so, you remove the boolean method parameter and add a new method for each control-flow path that the
        parameter was distinguishing between. You can even give the new methods expressive and meaningful names and further
        enhance the readability of the code!”

        “Good design is less clear-cut, and it requires you to have an intuition and a “feeling” for it. The only real way
        to get this intuition is to do a lot of coding, to try out different designs, and to see what fails and what feels just right.”

    52. “Split Method with Optional Parameters”
        “Booleans as you’ve seen them in Split Method with Boolean Parameters aren’t the only indicators of methods that
        do too much. Optional parameters have the same problem, but they’re harder to spot.”
            (for example a date parameter that if null returns all entries, and if not null returns all entries from that date to present)

        “The solution to the problem here is essentially the same as in Split Method with Boolean Parameters: we split
        the method into two methods. Each of them captures one of the control-flow branches.”

    53. “Favor Abstract Over Concrete Types”
        “If you use more abstract types for variables, your code will be more flexible.”

        “First, the supplies field uses the interface type List instead of LinkedList. This tells us that the supplies
        are stored in an order but not how they’re stored (in an array for the ArrayList or through linked wrapper
        objects for the LinkedList).”

        “Second, the method stockUp() accepts any Collection now. This is Java’s most general interface for storing
        objects in a data structure. It means that you can pass any subtype of Collection, any complex data structure in
        Java, into the method.”

        “Third, the method getContaminatedSupplies() returns a List instead of a more specific type. We guarantee only
        that the supplies are ordered, but not how the list is implemented internally. This makes the code more flexible.”

    54. “Favor Immutable Over Mutable State”
        “Whenever possible, you should make the state immutable because this makes objects harder to misuse.”

        “Note the usage of the final keyword in the code above. Now you need to set the value and unit fields in the
        constructor, and you can’t change them afterward. If you compute a distance, you need a new instance every time”

        “The downside of this solution is that we create more objects, but in Java small objects are cheap.

        In software design, this solution is the way to go for so-called value objects[42]: percentages, money, currency,
        times, dates, coordinates and, of course, distances. These objects are indistinguishable if their values are
        equal: $10 is $10, even if there’s a different object representing each of those dollars.
!!!!    So watch out for value objects and make them immutable!”

    55. “Combine State and Behavior”
        “Classes containing only behavior but lacking state indicate OO-design problems.”

        “The problem is that this separation (between state and behaviour) prohibits information hiding, and it makes
        the code more verbose.”

        “A separation of state and behavior is sometimes hard to detect. As a rule of thumb, you can look out for classes
        that are simply too large or that operate only on their method parameters. Try to simplify such classes by grouping
        variables and methods that perform similar tasks into one class each”

        “ Similarly, an Order or User in a different type of system can provide functionality on its own without a
        manager, controller, service, or any other stateless class.”
            Dan : not sure if I agree with this...doesn't this contradict the single responsability per class ????

        “Sometimes, frameworks require you to go against this rule. For example, controllers in web frameworks are typically
        stateless—that is, they have no fields, only method parameters. That’s by design to make it possible to create lots
        of such controllers to handle a large amount of parallel requests—with the state residing in the database only.”

        Excerpt From: Jörg Lenhard. “Java By Comparison”. Apple Books.

    56. Avoid Leaking References
        “Practically any nontrivial object has some inner state that’s accessible from the outside. You need to be careful
         how you make this state available. Otherwise, you risk serious bugs.”

        “Inventory(List<Supply> supplies) {                             BAD ? (DEPENDS ON usage..)
            this.supplies = supplies;
        }”

        “List<Supply> getSupplies() {                                   BAD
            return supplies;
        }”

        “Inventory(List<Supply> supplies) {                             GOOD/BETTER
            this.supplies = new ArrayList<>(supplies);
        }”

        “List<Supply> getSupplies() {                                   GOOD/BETTER
            return Collections.unmodifiableList(supplies);
        }”

        “The problem is that there’s only one list in memory—the one created by new ArrayList<>(). The inventory just
        stores a reference to that list in its supplies field and returns that reference through getSupplies().
        Essentially, the Inventory leaks the reference to its inner structure to the outside through the getter. This is
        bad! But there’s a way to avoid this.”

!!     “What’s more, it doesn’t expose the internal list through getSupplies() directly, but only after wrapping it as
        a unmodifiableList(). This ensures read-only access. If a call wants to add an element to the list, we would
        need to write an explicit method for that.”

        “This technique is also called defensive copying. Instead of reusing a passed data structure, you make a copy to
        avoid losing control.”

    57. Avoid Returning Null
        “When there’s no proper value to return in a method call, some programmers just return null. This can harm the
        stability of your program!”

!!!!!   “One solution would be to throw an exception—for example, an IllegalArgumentException or a NoSuchElementException.
        (INSTEAD OF returning null)
        This is a strong indication for a problem. You’d have to explicitly deal with it on the calling side.”

!!!!!   “But in this case, we propose you use the null object pattern. Instead of returning null, you return a null object,
        an object that explicitly indicates that it has no real value.”

        “static final SpaceNation UNKNOWN_NATION = new SpaceNation("", "");”
            (one can return this instead of a null SpaceNation object...)
        “It’s still up to the calling side to decide what to do when encountering an UNKNOWN_NATION. The difference is that
        we now have a choice if we want to ignore the value or throw an exception.”

        “Null objects come in different forms: empty strings, empty collections, or special instantiations of a class, as
        you can find here. But regardless of their form, they all help to overcome the “billion-dollar mistake”: the
        introduction of the null reference by Tony Hoare (he is credited with inventing the concept in the '60s)!

!!!!    In Favor Optional Over Null, we’ll show you how to force the developer to handle the presence and the absence of that value.”

    “What Have You Learned?”
        “The design of large software systems is tremendously hard but it has been explored a lot already. If you want to
        read more on this, we recommend the classic book on Design Patterns”


-------------------------------------------------------------------------------------------------------------------
“Chapter 8 - ““Let Your Data Flow”

    “Object-oriented programming makes code understandable by encapsulating moving parts.
    Functional programming makes code understandable by minimizing moving parts
        Michael Feathers”

    “The release of Java 8 was a similar revolution to the Java world. Since then, it’s become possible to use the
    functional programming paradigm with lambda expressions and streams in regular Java programs out of the box. Before
    that, you could only use functional programming on the JVM with different languages like Scala. Now you can combine
    all major programming styles easily in Java.”

    “No single programming style describes a fundamental truth. No style is always better than the others in all
    application scenarios. Each has its pros and cons, and it’s up to the developer to find out which suits a particular
    situation best.”

    58. “Favor Lambdas Over Anonymous Classes”
        “In the code above, the programmer instantiated an anonymous class to implement that interface. It’s called
        anonymous because there’s no class name and the class has only a single instance.”

        “Lambdas provide implementations for functional interfaces—that is, interfaces with a single abstract method.
        Here, lambdas are a perfect fit, because the Function interface has only a single abstract method: apply(). We
        can write a lambdas in various ways: as one-liners or in multiple lines”

        “You should avoid the multi-liner whenever possible and Favor Method References Over Lambdas instead. ”

        “In Java, you usually have to specify types everywhere explicitly.
        But for parameters of lambda expressions the compiler can figure out the types on its own in (almost) all
        cases: it searches for the single abstract method that the lambda expression implements and uses that method
        signature with its type specifications. This is called type inference. ”

    59. “Favor Functional Over Imperative Style”
        “When it comes to working with collections, a functional programming style can be much more readable than its
        imperative sibling.”
            Dan: debatable imo :)

        “But usually, we’re most interested in what the code does and not so much in how it reaches its goal. That’s why
        we invest so much effort in writing good comments and choosing good names.”

    60. “Favor Method References Over Lambdas”
        “Lambda expressions like you’ve seen them in the previous comparison can make your code more readable.
        But these benefits come at a price: you can’t execute lambda expressions partway—you can only run the whole
        stream. That means it’s hard to test parts of lambda expressions as you’d want to do in a unit test.”

!!!!    “Code that builds on method calls, on the other hand, is easier to test, because you can call the methods
        separately from their integration. Luckily, functional programming in Java also provides a mechanism to take
        care of this: method references. Using method references, you can embed method calls directly as a lambda
        expression, and that makes quality assurance easier.”

        “At this point, you might think about converting your lambda expressions into methods.
        You should do that when the expression is rather complex or when you need it multiple times to avoid “lambda duplication.”

   61. Avoid Side Effects
        “In theory, there are no side effects with functional programming. Everything’s just a function that takes data as
        input and produces new data as output. The data you pass along is immutable.
        But in imperative and object-oriented programming, we rely on side effects (we change data and state through
        procedures or methods) all the time. In Java, we can now mix all these styles. This is very powerful, but it’s also
        quite error prone. That’s why you should try to minimize side effects in your code."

        “This Consumer adds an element to a list outside of the lambda expression. That’s the side effect.

        “There’s no functional error in the code above, but it’s prone to break once you add concurrency. Java makes no
        guarantees regarding the visibility of side effects among different threads. And already if you parallelize the
        lambda expression here, it will (occasionally) produce wrong results because the ArrayList is not thread-safe.”

!!!     “ beginners often fall back to the imperative style to terminate the stream—and this can only be done through side effects.”

!!!     “To sum up, you should try to avoid forEach() for terminating a stream, because it can easily cause side effects.
        Try to use collect() and reduce() instead, which we’ll explain more closely in Use Collect for Terminating
        Complex Streams. These operators terminate a stream directly and produce the data structure you need, be it a
        List, Set, or even a long. This makes your lambda expressions less error prone.”

    62. “Use Collect for Terminating Complex Streams”
        “If you want to get a Collection as the result of a stream, Java provides you with the collect() operator that
         we’ve mentioned in Avoid Side Effects and many predefined Collectors that you can use out of the box.
         You already know a few of these, like toList(), toSet(), or toMap(). But there are several others, and they’re quite powerful.”

        “we use the Collectors.groupingBy() operator on the stream of Supply instances. This operator will always return
        you a Map data structure.”

        “There are a lot of additional helpful collectors available, like partitioningBy(), maxBy(), joining(),
        mapping(), summingInt(), averagingLong(), and, of course, reducing(). In Java 9, you can even use filtering()
        and flatMapping(), too!”

    63. “Avoid Exceptions in Streams”
        “By design streams don’t go well with checked exceptions. You have to handle them inside the stream.”

        “Essentially, this comes from a mismatch of paradigms. Functions work on inputs and produce outputs.
        Functions don’t throw (or catch) exceptions.”

            .map(path -> {
                try {
            	    return new LogBook(path);
            	} catch (IOException e) {
            	    throw new UncheckedIOException(e);                      BAD
          	    }
            })
           .collect(Collectors.toList());”

           .flatMap(path -> {
            try {
           	    return Stream.of(new LogBook(path));
           	} catch (IOException e) {
           	    return Stream.empty();                                          GOOD
           	}
           	})
           	.collect(Collectors.toList());”

        “As you can see, we still have a try-catch block in the code above. There’s no way around this, but we no longer
        convert the checked exception to an unchecked one. Instead, we simply remove the exceptional element from the stream.

!!!!    To do so, we used the flatMap() operator. This one’s similar to map(), but instead of mapping a type to another one,
        it maps a type to a Stream of another type. If everything goes right, we simply create a new stream for a single
        element with Stream.of(element). If there are problems, we just return Stream.empty().”

!!      “In a nutshell: You’re better off in the functional style if you avoid exceptions”

    64. “Favor Optional Over Null”
        “Using null references is fine for internal state where you have full control over how the reference is accessed.
        But exposing it makes the program fragile because every caller needs to check for null, which is something that
        people easily forget.”

        “An Optional is a placeholder for an object that may or may not be present. You create it by calling
        Optional.ofNullable() with a reference that may point to an object or to null”
        “The big difference is that you can now spot the potential unavailability (OF an instance...hence the null posibility)
        in the method signature.”

        “But the Optional provides a handy method: ifPresent(). This method executes a Consumer you pass in, but only
        if the value within the Optional isn’t null. Here, we simply pass in a Consumer that sends messages.
        NullPointerException prevented!”

    65. “Avoid Optional Fields or Parameters”
        “When people learn about Optional, they start to apply it everywhere and for everything.
        Don’t make this mistake!
        There are situations where Optional can make your code more complicated and inconvenient to use. So let’s go over
        where you should avoid it.”

!!!!    “We know that an Optional has two states: it’s absent (or Optional.empty()) or present. Those states make sense. But
        if you have an optional field or method parameter, then this variable can be null as well.
        So suddenly you have three states: present, absent, or null.
        What’s it supposed to mean if an Optional is null from a semantic point of view? Is it even more absent? That
        doesn’t really make sense. Maybe null in this case means that the current connection should be reset?
        This isn’t clear from the code.”

        “Using optional for typing fields or parameters just makes everything more complicated. We can set fields to
        null and pass null to methods even with Optional fields or parameters. If you use them, you’ll have to check not
        only for null values, but also whether a value is present.”

        “you should remove the Optional part in the types of fields and method parameters.
        You should keep the Optional types only as return values. This removes the semantic overload between
        Optional.empty() and null values.”

    66. “Use Optionals as Streams”
!!!!     “An Optional is also a special kind of stream, one with either zero or exactly one element.”
         “That means that you can directly apply all regular stream operations, such as filter() or map(), to an Optional.
         This makes for a good opportunity to write more concise code.”

         “ Just use the arsenal of methods available in the Optional class: the intermediate operations filter(),”
         “map(), and flatMap(), and the terminal operations orElse(), orElseThrow(), orElseGet(), and ifPresent().”


-------------------------------------------------------------------------------------------------------------------
“Chapter 9 - “Prepare for the Real World”

    “The first 90% of the code accounts for the first 90% of the development time.
    The remaining 10% of the code accounts for the other 90% of the development time.”
        Tom Cargill

    “The key to coping with this pace is to embrace change—that’s a part of the agile philosophy. Don’t view changing
    requirements and circumstances as annoying, but as a sign that your software is useful, and be ready to adapt on the fly.”

    “In the last chapter, we’ll touch on general aspects regarding building and running your software, like applying
    static analysis tools, automating your build so you can do continuous integration and delivery, monitoring your
    software in production, and speeding it up with concurrency”

    67. “Use Static Code Analysis Tools”
        “Static analysis tools provide such a bar for the quality of your code. They investigate your code and look for
        potential bugs or code smells.”

        “SpotBugs,[47] or its predecessor FindBugs, is one of the oldest static code analysis tools for Java. It detects
        over 400 types of potential bugs”

        “Checkstyle[49] and PMD[50] are two other popular tools that are quite similar to SpotBugs. Their main difference
        is that they’re highly configurable, which makes them a powerful help if you want to ensure a certain code style.
        The downside is they’re quite verbose, and you’ll usually want to configure them specifically for your project,
        which can be tricky. ”

        “Error Prone[51] is yet another popular static analysis tool that’s more of an enhancement to the Java compiler.
        It performs more advanced type checks and, thankfully, provides suggestions for fixes to the numerous issues it
        can find. It’s built by Google for their own Java code base, but the tool is open source.”

    68. “Agree On the Java Format in Your Team”
        ““Code formatting is a topic that easily leads to heated debates even when you talk about the same language.
        Already the length of a line of code can be discussed. Should a line of code be set to 80 characters as it has
        been traditionally or 120 characters because we have widescreen displays today? Maybe 100 characters is a good
        compromise? Probably the most famous discussion point is whether you should indent code with tabs or spaces.
        Few things are more controversial among developers. Ultimately, there’s no right or wrong here. The problem is
        that all team members need to agree on a consistent formatting style to avoid constant reformatting and even bugs.”

    69. Automate Your Build
        “Gradle[57] is such a tool. It’s the rising star for Java and the default build system for
        Android, but you’ll also use Apache Maven,[58] the established enterprise standard, or Apache Ant[59] often.

    70. Use Continuous Integration
        “All of these things—extensive testing, integration, and code quality checks—can be outsourced to dedicated
        machines: continuous integration servers. The idea behind it all is very simple: for every commit to the version
        control system, a dedicated server pulls all code, executes all tests, and builds a fully integrated executable.
        It runs code quality checks and compares the results to the data from the commits before, thereby building a
        timeline for the quality of your code. That way, it’s easy to make sure that your project is always buildable and
        quality doesn’t go down.”

        “On your own server, you can install Jenkins,[60] one of the most popular continuous integration systems in the
        Java world. It can run your tests, and there are many plugins for quality checks. But you can also use a dedicated
        quality analysis server. Here, the market leader is SonarQube,[61] which you can host yourself or use their cloud solution. ”

    71. “Prepare for and Deliver Into Production”
       “One part of that preparation is to implement monitoring in the form of logs, metrics, dashboards, and alerts.
        First, you should Favor Logging Over Console Output, which we’ll explain to you in a moment. Next, you should
        set up a central place where all your logs go. If the logs are also searchable and you can analyze them, compute
        metrics, and visualize them in a dashboard, that’s perfect. Then, you might be able to derive key insights and
        thresholds, like how many orders were placed within the last 24 hours. And if such a metric is below a target
        threshold, you’ll probably want to alert the person who can bring that metric up again. For things like this,
        we can recommend the Open Source Elastic Stack[64] and Graylog”

    72. “Favor Logging Over Console Output”

    73. “Minimize and Isolate Multithreaded Code”
        “Concurrency isn’t easy to grasp, and it’s even harder to code correctly. Bugs in concurrent software can result
        in huge problems and even loss of life, according to An Investigation of the Therac-25 Accidents [LT93]. And the
        bad news continue: tests and static analysis are notoriously bad at ensuring the correctness of concurrent code.
        Although costly, manual code reviews are usually a better choice.”

        “Well, first of all, avoid premature optimization and multithreaded code until you have a good reason for it,
        like terrible results from a performance benchmark. Your first guess should be that a sequential solution is
        fast enough. Only after you measure your code and it’s too slow should you go for multithreading.”

        “We recommend that you keep multithreaded code as isolated as possible—limited to few packages in your code base,
        for example—and to document it thoroughly.”

!!      “That’s why you should document concurrent access to mutable data in your code, especially how this data is
        protected from concurrency bugs. We recommend that you use the JCIP Annotations stemming from the famous book
        Java Concurrency in Practice [Goe06], which also explains all the nitty-gritty details of concurrency in Java.”

    74. “Use High-Level Concurrency Abstractions”
        “Sometimes (most of the time, actually), you just need to make your program multithreaded. For example, you
        might have to handle multiple users at the same time in a web application. Or maybe you’ve got a desktop or
        Android application that interacts with the user and the screen in a UI thread and executes compute-intense tasks
        in background threads.

        In those cases, you’ll typically let your threads communicate via shared memory: one thread writes a variable
        that another one reads, and vice versa. Java has supported such a built-in threading model and synchronization
        primitives since its inception. That’s been one of its major advantages in comparison to other high-level
        languages at the time.”

        “The language has evolved a lot and has undergone many improvements in terms of higher-level classes for writing
        concurrent code. We recommend that you rely exclusively on these higher-level classes. There’s more of them than
        we can reasonably cover here, but examples are synchronization classes such as Semaphore, CountDownLatch, or
        CyclingBarrier and data structures such as AtomicInteger, LongAdder, ConcurrentHashMap, CopyOnWriteArrayList, or
        BlockingQueue.”

    75. “Speed Up Your Program”
        “return supplies.stream()                                                   SLOW when dealing with a lot of entries
            .sequential() // this can be omitted
            .filter(Supply::isUncontaminated)
            .map(Supply::getName)
            .distinct()
            .count();”

        “return supplies.stream()                                                   FAST when dealing with a lot of entries
            .parallel()
            .filter(Supply::isUncontaminated)
            .map(Supply::getName)
            .distinct()
            .count();”

        “Remember, streams define what should be computed, instead of listing every detail how the computation happens.
        Now we bring this paradigm to its pinnacle by just telling the stream that it should execute in parallel—without
        actually describing how it should do that. That’s as easy as switching our stream from sequential() to parallel().”

        “But be aware that this solution works only when you have a stream without side effects and where single
        processing steps are independent. There’s a considerable overhead if you use operations that force the stream to
        synchronize again, such as sort() or forEachOrdered(). In that case, the sequential() option might actually be faster.”

   76. Know Your Falsehoods
        “Some names, even simple ones, are special in other ways, and that can cause problems. Look at the case of
        Christopher Null whose last name is, well, “Null”—something that prevents him from submitting a lot of forms in
        the web. Some frameworks and programs interpret his name as a null reference—and prevent this poor guy from
        entering his name into forms.”

        “But the list of falsehoods doesn’t stop here. Email addresses, postal codes, CSV files, and our favorite:
        time zones. It’s an incredibly challenging task to correctly calculate the difference in minutes between two
        localized daytimes.
        The point is to make you aware that you should be careful with assumptions when you program. In theory, they may
        seem fine. But they often break in practice. Always think twice before you let your code be guided by sheer
        assumptions to make your code ready for the real world!”

   “What Have You Learned?
        You’ve made it! This is the end of this book. We’re happy that you’ve taken this journey with us, and we hope
        you’ll remember: the journey’s the reward. You’ve learned so much along the way.

        We covered 70 examples, including code style, comments, naming, exceptions, testing, object-oriented design,
        and functional programming to sharpen your understanding of high-quality code.”

        “Obviously, it’s not just about reading the book, but about applying the principles in practice. So be sure to
        practice. And when you do, use the comparisons in this book to help you to produce better code”






















